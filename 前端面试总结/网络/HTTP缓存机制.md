## HTTP缓存机制

### 设置缓存的方式

1. HTML meta标签
2. http报文

### 缓存位置

1. Service work

   介于浏览器和网络之间的代理，具有：独立线程、不阻塞等特点，可以用于拦截页面所有请求，可以使用`cacheStorage`来缓存文件和数据。

2. Memory cache

   用户在打开网页到关闭浏览器之前，浏览器会把资源加载到内存，这时候在没有关闭tab页的时候，总是先从`memory cache`中获取数据。

3. Desk cache

   持久化的缓存用户访问过的资源，当用户打开浏览器的时候，会优先从`desk cache`中获取数据，如果`desk cache`过期，则再请求远端服务器。

### 缓存过程分析

1. 浏览器第一次发起请求，这时候会拿到请求的结果和缓存标识
2. 将缓存标识和结果存入浏览器缓存
3. 下一次发起请求时，先查看缓存是否有效
4. 若无效，则携带缓存标识向服务端发起请求
5. 服务端根据缓存标识来判断资源是否有过更新
6. 若未更新，则返回304和一个空的response body
7. 浏览器接收到304状态码，则取缓存中对应资源
8. 若有更新，则返回新的资源以及该资源的缓存标识
9. 浏览器用最新的资源和缓存标识替换过期缓存

### 强缓存

强缓存对应上面1 ～ 4 步，这时候浏览器会固定取缓存中的资源，然后判断缓存是否有效。

#### 如何设置？

+ HTML meta标签

  ```html
  <meta http-equiv="Pragma" content="no-cache" />
  ```

  > 兼容性差！

+ HTTP报文

  1. Expires

     顾名思义，这是设置缓存的过期时间，格式大概是`Expires: Wed, 22 Oct 2018 08:41:00 GMT`

     Expires是HTTP 1.0的产物，算是一种过时的设计

     Expires受限于本地时间，如果更改了本地时间，则可能会造成缓存的实效（比较本地时间和Expires）

  2. Cache-Control

     HTTP 1.1中新定义的字段，他可以设置多个值：

     | 指令         | 含义                                                       |
     | ------------ | ---------------------------------------------------------- |
     | public       | 表示相应可以被客户端和代理服务器缓存                       |
     | private      | 表示只可以被客户端缓存                                     |
     | max-age=30   | 缓存30秒后过期，需要重新请求                               |
     | s-maxage=30  | 覆盖max-age，作用一样，只在代理服务器中生效                |
     | no-store     | 不缓存                                                     |
     | no-cache     | 资源缓存，但是会立即失效，以后每次请求都要校验缓存是否过期 |
     | max-stale    | 30秒内，机试缓存过期，也使用该缓存                         |
     | min-fresh=30 | 希望在30秒内获取最新的响应                                 |

  3. Expires Vs Cache-Control

     Cache-Control优先级高于Expires，同时设置的情况下只有客户端不支持HTTP1.1的时候，Expires才会生效。

#### 适用性

强缓存一般是针对静态资源使用，用于提高网站的访问速度

因为代理服务器不会解析HTML，所以HTML的meta标签堆代理服务器并不会生效



### 协商缓存

当强缓存失效时，这时候就到了协商缓存了

所谓的协商缓存，就是客户端请求资源的时候带上缓存标识，然后服务端判断这个缓存是否有效（文件是否有更新）。

如果没有更新，则返回一个状态码为304，响应体为空的报文；如果有更新，则返回状态码为200，并且返回最新的资源。

#### 缓存标识

1. Last-Modified/If-Modified-Since

   客户端获取服务端的资源的时候，响应报文中会带有`Last-Modified`字段，用来标识该文件最后一次修改时间。然后当客户端缓存过期，请求最新资源的时候，请求报文中会把`Last-Modified`的值作为`If-Modified-Since`的值传到服务端，服务端根据文件的修改时间来判断，当前文件是否修改过。

2. Etag

   客户端获取服务端资源的时候，服务器通过文件指纹算法，算出来一个文件tag，每次文件内容有改动，这个tag都会变，然后客户端请求最新资源的时候会带上这个Etag，服务端根据文件指纹是否不同，判断当前文件是否有修改。

#### Last-Modified Vs Etag

1. Etag优先级高于Last-Modified

2. Last-Modified在准确度上没有Etag高
3. Etag效率低于Last-Modified



### 用户行为对缓存的影响

1. 打开网页：强缓存 -> 协商缓存
2. 普通刷新：memory cache -> desk cache -> 协商缓存
3. 强制刷新（Ctrl + F5）：请求最新资源，request head 均带有 cache-control: no-cache